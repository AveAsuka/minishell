---

0. Имя
env -- установить среду и выполнить команду или среду печати

Краткий обзор
env [-iv] [-P altpath] [-S string] [-u name] [name=value ...] [utility [argument ...]]

---

I. Описание
Утилита env выполняет другую утилиту после изменения среды, как указано в командной строке. 
Каждый параметр name=value задает параметр переменной среды name со значением value. 
Все такие переменные среды устанавливаются перед выполнением утилиты.

---

II. Варианты заключаются в следующем:

1) -i     
Запустите утилиту только с теми переменными среды, которые указаны в параметрах name=value. 
Среда, унаследованная env, полностью игнорируется.

2) -P altpath
Выполните поиск по набору каталогов, как указано в altpath, чтобы найти указанную служебную программу,
вместо того, чтобы использовать значение переменной среды PATH.

3) -S string
Разделите заданную строку на несколько строк и обработайте каждую из результирующих строк в качестве 
отдельных аргументов утилиты env. Опция -S распознает некоторые экранирующие последовательности 
специальных символов, а также поддерживает замену переменных среды, как описано ниже.

4) -u name
Если имя переменной среды находится в среде, то удалите его перед обработкой остальных параметров. 
Это похоже на команду unset в sh(1). Значение для имени не должно содержать символ `='.

5) -v      
Распечатайте подробную информацию для каждого шага обработки, выполняемого утилитой env. 
Дополнительная информация будет напечатана, если -v указано несколько раз.

---

III. Вышеуказанные параметры распознаются только в том случае, если они указаны перед любыми параметрами name=value.
Если утилита не указана, env выводит имена и значения переменных в среде с одной парой имя/значение на строку.

---

IV. Подробности обработки -S (разделенной строки)
Обработка параметра -S разделит данную строку на отдельные аргументы на основе любых пробелов или символов <табуляции>, найденных в строке.
Затем каждый из этих новых аргументов будет рассматриваться так, как если бы он был конкретизирован. Опция -S распознает некоторые экранирующие последовательности специальных символов, а также поддерживает замену переменных среды, как описано ниже.

-u name
Если имя переменной среды находится в среде, то удалите его перед обработкой остальных параметров. 
Это похоже на команду unset в sh(1). Значение для имени не должно содержать символ `='.

-v   
Распечатайте подробную информацию для каждого шага обработки, выполняемого утилитой env. 
Дополнительная информация будет напечатана, если -v указано несколько раз.

Вышеуказанные параметры распознаются только в том случае, если они указаны перед любыми параметрами name=value.
Если утилита не указана, env выводит имена и значения переменных в среде с одной парой имя/значение на строку.

---

V. Подробности обработки -S (разделенной строки)
Обработка параметра -S разделит данную строку на отдельные аргументы на основе любых пробелов или символов 
<табуляции>, найденных в строке. Затем каждый из этих новых аргументов будет обрабатываться так, 
как если бы он был указан как отдельный аргумент в исходной команде env.

Пробелы и символы табуляции могут быть вставлены в один из этих новых аргументов с помощью одинарных (`"') 
или двойных (""') кавычек или обратной косой черты (`\').  Одинарные кавычки экранируют все символы, 
не заключенные в одинарные кавычки, вплоть до соответствующей одинарной кавычки.  Двойные кавычки экранируют 
все символы, не заключенные в двойные кавычки, вплоть до соответствующей двойной кавычки.  
Это ошибка, если конец строки достигнут до соответствующего символа кавычки.

Если -S создаст новый аргумент, начинающийся с символа `#', то этот аргумент и остальная часть строки будут 
проигнорированы.  Последовательность `\#' можно использовать, если вы хотите, чтобы новый аргумент начинался 
с символа `#', не вызывая пропуска остальной части строки.

При обработке строкового значения обработка -S будет обрабатывать определенную полезность.  
Опция -S распознает некоторые экранирующие последовательности специальных символов, а также 
поддерживает замену переменных среды, как описано ниже.

-u name
Если имя переменной среды находится в среде, тоудалите его перед обработкой остальных параметров.  
Это похоже на команду unset в sh(1).  Значение для имени не должно содержать символ `='.

-v   
Распечатайте подробную информацию для каждого шага обработки, выполняемого утилитой env.  
Дополнительная информация будет напечатана, если -v указано несколько раз.

Вышеуказанные параметры распознаются только в том случае, если они указаны перед любыми параметрами name=value.
Если утилита не указана, env выводит имена и значения переменных в среде с одной парой имя/значение на строку.

---

VI. Подробности обработки -S (разделенной строки)
Обработка параметра -S разделит данную строку на отдельные аргументы на основе любых пробелов или символов 
<табуляции>, найденных в строке. Затем каждый из этих новых аргументов будет обрабатываться так, 
как если бы он был указан как отдельный аргумент в исходной команде env.

Пробелы и символы табуляции могут быть вставлены в один из этих новых аргументов с помощью одинарных (`"') 
или двойных (""') кавычек или обратной косой черты (`\').  Одинарные кавычки экранируют все символы,
не заключенные в одинарные кавычки, вплоть до соответствующей одинарной кавычки.  
Двойные кавычки экранируют все символы, не заключенные в двойные кавычки, вплоть до соответствующей двойной кавычки.
Это ошибка, если конец строки достигнут до соответствующего символа кавычки.

Если -S создаст новый аргумент, начинающийся с символа `#', то этот аргумент и остальная часть строки
будут проигнорированы. Последовательность `\#' можно использовать, если вы хотите, чтобы новый аргумент
начинался с символа `#', не вызывая пропуска остальной части строки.

При обработке строкового значения обработка -S будет обрабатывать определенные комбинации символов 
как escape-последовательности, которые представляют собой некоторые действия, которые необходимо предпринять.
Экранирующие последовательности символов представлены в виде обратной косой черты. 
Символы и их значения следующие:
    \c Игнорирует остальные символы в строке. Это не должно отображаться внутри строки, 
    заключенной в двойные кавычки.
    \f Замените символом <form-feed>.
    \n Замените символом <новая строка>.
    \r Замените символом <возврат каретки>.
    \t Замените символом <tab>.
    \v Замените символом <вертикальная вкладка>.
    \# Замените символом `#'.  Это было бы полезно, когда вам нужен `#' в качестве первого символа 
    в одном из аргументов, созданных путем разделения заданной строки.
    \$ Замените символом `$'.
    \_ Если это значение находится внутри строки, заключенной в двойные кавычки, замените его одним пробелом. 
    Если это будет найдено снаружи строки, заключенной в кавычки, затем рассматривайте это как
    символ-разделитель между новыми аргументами в исходной строке.
    \" Замените символом <двойная кавычка>.
    \' Заменить символом <одинарная кавычка>.
    \\ Замените символом обратной косой черты.

Последовательности для <одинарных кавычек> и обратной косой черты являются единственными последовательностями, 
которые распознаются внутри строки, заключенной в одинарные кавычки. Остальные последовательности не имеют особого
значения внутри строки, заключенной в одинарные кавычки. Все escape-последовательности распознаются внутри строки,
заключенной в двойные кавычки. Это ошибка, если за одним символом `\' следует символ, отличный от перечисленных выше.

Обработка -S также поддерживает подстановку значений из переменных среды. Для этого имя переменной окружения
должно находиться внутри `${}', например: ${SOMEVAR}.  Общий синтаксис оболочки $SOMEVAR не поддерживается.
Все замененные значения будут значениями переменных среды, какими они были при первоначальном вызове утилиты env.
Эти значения не будут проверяться ни для одной из escape-последовательностей, как описано выше.
И любые настройки name=value не повлияют на значения, используемые для подстановки в обработке -S.

Кроме того, обработка -S не может ссылаться на значение специальных параметров, которые определяются большинством
оболочек.  Например, -S не может распознать специальные параметры, такие как: `$*', `$@', `$#', `$?' или `$$',
если они появляются внутри данной строки.

---

VII. Использование в shell-скриптах
Утилита env часто используется в качестве интерпретатора в первой строке интерпретируемых сценариев, 
как описано в execve(2).

Обратите внимание, что способ, которым ядро анализирует `#!' (первую строку) интерпретируемого скрипта, 
изменился с версии FreeBSD 6.0. До этого ядро FreeBSD разбивало эту первую строку на отдельные аргументы 
на основе любых пробелов (пробелов или символов <tab>), найденных в строке. 
Итак, если сценарий с именем /usr/local/bin/someport содержал первую строку:
           #!/usr/local/bin/php -n -q -dsafe_mode=0

тогда программа /usr/local/bin/php была бы запущена с аргументами:
           arg[0] = '/usr/local/bin/php'
           аргумент[1] = '-n'
           аргумент[2] = '-q'
           аргумент[3] = '-dsafe_mode=0'
           arg[4] = '/usr/local/bin/someport'

плюс любые аргументы, указанные пользователем при выполнении someport. Однако эта обработка нескольких параметров
в строке `#!' отличается от того, как любая другая операционная система анализирует первую строку интерпретируемого
скрипта.

Таким образом, после изменения, которое было внесено для выпуска FreeBSD 6.0, этот скрипт приведет к запуску 
/usr/local/bin/php с аргументами:
           arg[0] = '/usr/local/bin/php'
           аргумент[1] = '-n -q -dsafe_mode=0'
           arg[2] = '/usr/local/bin/someport'

плюс любые аргументы, указанные пользователем. Это привело к значительным изменениям в поведении нескольких 
скриптов.  В случае вышеупомянутого скрипта, чтобы он вел себя так же под FreeBSD 6.0, как и в предыдущих версиях,
первую строку следует изменить на:
           #!/usr/bin/env -S /usr/local/bin/php -n -q -dsafe_mode=0

Утилита env будет запущена со всей строкой в качестве единственного аргумента:
           arg[1] = '-S /usr/local/bin/php -n -q -dsafe_mode=0'

и затем обработка -S разделит эту строку на отдельные аргументы перед выполнением /usr/local/bin/php.

---

VIII. Прочее

Окружающая среда
Утилита env использует переменную окружения PATH для поиска запрашиваемой утилиты, если имя не содержит
 символов `/', если не указана опция -P.

СТАТУС ВЫХОДА
Утилита env завершает работу с 0 при успешном завершении и >0 при возникновении ошибки. 
Статус выхода 126 указывает на то, что утилита была найдена, но не может быть выполнена. 
Статус выхода 127 указывает на то, что утилита не может быть найдена.

Примеры:
Поскольку утилита env часто используется как часть первой строки интерпретируемого скрипта, в следующих примерах
показан ряд способов, которыми утилита env может быть полезна в сценариях.

Обработка ядром интерпретируемого скрипта не позволяет скрипту напрямую ссылаться на какой-либо другой скрипт
в качестве своего собственного интерпретатора.  Как способ обойти это, основное различие между
            #!/usr/local/bin/foo
        и
            #!/usr/bin/env /usr/local/bin/foo
заключается в том, что последнее работает, даже если /usr /local/bin /foo сам по себе является 
интерпретируемым скриптом.

Вероятно, наиболее распространенным использованием env является поиск правильного интерпретатора для скрипта, 
когда интерпретатор может находиться в разных каталогах в разных системах.  
В следующем примере интерпретатор `perl' будет найден путем поиска по каталогам, указанным по ПУТИ.
           #!/usr/bin/env perl

Одним из ограничений этого примера является то, что он предполагает, что пользовательское значение для
PATH установлено на значение, которое найдет интерпретатор, который вы хотите выполнить.  
Параметр -P можно использовать, чтобы убедиться, что при поиске утилиты используется определенный список каталогов.
Обратите внимание, что для корректной работы этого примера также требуется параметр -S.
           #!/usr/bin/env -S -P/usr/local/bin:/usr/bin perl

Приведенный выше метод находит `perl' только в том случае, если он находится в /usr/local/bin или /usr/bin.
Это можно было бы объединить с текущей стоимостью PATH, чтобы обеспечить большую гибкость.
Обратите внимание, что пробелы между параметрами -S и -P не требуются:
           #!/usr/bin/env -S-P/usr/local/bin:/usr/bin:${PATH} perl

Совместимость
Утилита env принимает параметр - в качестве синонима -i.

Смотрите также
printenv(1), sh(1), execvp(3), environ(7)

Стандарты
Утилита env соответствует стандарту IEEE Std 1003.1-2001 (`POSIX.1").
Опции -P, -S, -u и -v - это нестандартные расширения, поддерживаемые FreeBSD, но которые могут быть
недоступны в других операционных системах.

История
Команда env появилась в версии 4.4BSD.  Опции -P, -S и -v были добавлены во FreeBSD 6.0.

Ошибки
Утилита env по понятным причинам не обрабатывает значения утилиты, в имени которых есть знак равенства (`=').
Утилита env не учитывает многобайтовые символы при обработке параметра -S, что может привести
к неправильным результатам в некоторых локализациях.

---
